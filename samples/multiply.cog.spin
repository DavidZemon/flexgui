'' automatically generated by fastspin v3.8.0-beta on Wed May 16 19:53:11 2018
'' command line: /home/ersmith/Parallax/spin2cpp/build/fastspin -w -2 multiply.spin 

CON
	__MBOX_SIZE = 6
	__STACK_SIZE = 1
VAR
  long __mbox[__MBOX_SIZE]   ' mailbox for communicating with remote COG
  long __objmem[0]          ' space for hub data in COG code
  long __stack[__STACK_SIZE] ' stack for new COG
  byte __cognum              ' 1 + the ID of the running COG (0 if nothing running)

'' Code to start the object running in its own COG
'' This must always be called before any other methods
PUB __coginit(id)
  if (__cognum == 0) ' if the cog isn't running yet
    __fixup_addresses
    longfill(@__mbox, 0, __MBOX_SIZE)
    __mbox[1] := @entry
    __mbox[2] := @__objmem
    __mbox[3] := @__stack
    if (id < 0)
      id := cognew(@entry, @__mbox)
    else
      coginit(id, @entry, @__mbox) ' actually start the cog
    __cognum := id + 1
  return id

PUB __cognew
  return __coginit(-1)

'' Code to stop the remote COG
PUB __cogstop
  if __cognum
    __lock  ' wait until everyone else is finished
    cogstop(__cognum~ - 1)
    __mbox[0] := 0
    __cognum := 0

'' Code to lock access to the PASM COG
'' The idea here is that (in theory) multiple Spin bytecode threads might
'' want access to the PASM COG, so this lock mackes sure they don't step on each other.
'' This method also makes sure the remote COG is idle and ready to receive commands.
PRI __lock
  repeat
    repeat until __mbox[0] == 0   ' wait until no other Spin code is using remote
    __mbox[0] := __cognum         ' try to claim it
  until __mbox[0] == __cognum     ' make sure we really did get it

  repeat until __mbox[1] == 0     ' now wait for the COG itself to be idle

'' Code to release access to the PASM COG
PRI __unlock
  __mbox[0] := 0

'' Check to see if the PASM COG is busy (still working on something)
PUB __busy
  return __mbox[1] <> 0

'' Code to send a message to the remote COG asking it to perform a method
'' func is the PASM entrypoint of the method to perform
'' if getresult is nonzero then we wait for the remote COG to answer us with a result
'' if getresult is 0 then we continue without waiting (the remote COG runs in parallel
'' We must always call __lock before this, and set up the parameters starting in __mbox[2]
PRI __invoke(func, getresult) : r
  __mbox[1] := func - @entry     ' set the function to perform (NB: this is a HUB address)
  if getresult                   ' if we should wait for an answer
    repeat until __mbox[1] == 0  ' wait for remote COG to be idle
    r := __mbox[2]               ' pick up remote COG result
  __unlock                       ' release to other COGs
  return r

'' Code to convert Spin relative addresses to absolute addresses
'' The PASM code contains some absolute pointers internally; but the
'' regular Spin compiler cannot emit these (bstc and fastspin can, with the
'' @@@ operator, but we don't want to rely on having those compilers).
'' So the compiler inserts a chain of fixups, with each entry having the Spin
'' relative address in the low word, and a pointer to the next fixup in the high word.
'' This code follows that chain and adjusts the relative addresses to absolute ones.
PRI __fixup_addresses | ptr, nextptr, temp
  ptr := __fixup_ptr[0]
  repeat while (ptr)      ' the fixup chain is terminated with a 0 pointer
    ptr := @@ptr          ' point to next fixup
    temp := long[ptr]     ' get the data
    nextptr := temp >> 16 ' high 16 bits contains link to next fixup
    temp := temp & $ffff  ' low 16 bits contains real pointer
    long[ptr] := @@temp   ' replace fixup data with real pointer
    ptr := nextptr
  __fixup_ptr[0] := 0 ' mark fixups as done

'--------------------------------------------------
' Stub functions to perform remote calls to the COG
'--------------------------------------------------

PUB Builtinmul(A, B) : r0, r1, r2
  __lock
  __mbox[2] := A
  __mbox[3] := B
  __mbox[1] := @pasm_Builtinmul - @entry
  repeat until __mbox[1] == 0
  r0 := __mbox[2]
  r1 := __mbox[3]
  r2 := __mbox[4]
  __unlock

PUB Cordicmul(A, B) : r0, r1, r2
  __lock
  __mbox[2] := A
  __mbox[3] := B
  __mbox[1] := @pasm_Cordicmul - @entry
  repeat until __mbox[1] == 0
  r0 := __mbox[2]
  r1 := __mbox[3]
  r2 := __mbox[4]
  __unlock

PUB Hwmul(A, B) : r0, r1, r2
  __lock
  __mbox[2] := A
  __mbox[3] := B
  __mbox[1] := @pasm_Hwmul - @entry
  repeat until __mbox[1] == 0
  r0 := __mbox[2]
  r1 := __mbox[3]
  r2 := __mbox[4]
  __unlock

PUB Swmul(A, B) : r0, r1, r2
  __lock
  __mbox[2] := A
  __mbox[3] := B
  __mbox[1] := @pasm_Swmul - @entry
  repeat until __mbox[1] == 0
  r0 := __mbox[2]
  r1 := __mbox[3]
  r2 := __mbox[4]
  __unlock

'--------------------------------------------------
' The converted object (Spin translated to PASM)
' This is the code that will run in the remote COG
'--------------------------------------------------

DAT
	org	0
entry
	mov	mboxptr, ptra
	add	mboxptr, #8
	rdlong	objptr, mboxptr
	add	mboxptr, #4
	rdlong	ptra, mboxptr
	sub	mboxptr, #8
	wrlong	#0, mboxptr
waitloop
	rdlong	mboxcmd, mboxptr wz
 if_e	jmp	#waitloop
	add	mboxptr, #4
	rdlong	arg1, mboxptr
	add	mboxptr, #4
	rdlong	arg2, mboxptr
	sub	mboxptr, #4
	shr	mboxcmd, #2
	calla	mboxcmd
	wrlong	result1, mboxptr
	add	mboxptr, #4
	wrlong	result2, mboxptr
	add	mboxptr, #4
	wrlong	result3, mboxptr
	sub	mboxptr, #12
	mov	arg1, #0
	wrlong	arg1, mboxptr
	jmp	#waitloop

' 
' ''
' '' module for testing various forms of multiply
' ''
' PUB builtinmul(a, b) : r1, r2, t
pasm_Builtinmul
_Builtinmul
'   t := CNT
	getct	result1
	mov	_var_T, result1
'   r1 := a*b
	mov	muldiva_, arg1
	mov	muldivb_, arg2
	calla	#multiply_
'   r2 := a**b
'   t := CNT - t
	getct	result1
	sub	result1, _var_T
	mov	result3, result1
	mov	result1, muldiva_
	mov	result2, muldivb_
_Builtinmul_ret
	reta

' 
' PUB cordicmul(a, b) : lo, hi, t | m1, m2
pasm_Cordicmul
_Cordicmul
'   t := CNT
	getct	result1
	mov	_var_T, result1
	qmul	arg1, arg2
	getqx	_var_Lo
	getqy	result2
'   asm
'     qmul a, b
'     getqx lo
'     getqy hi
'   endasm
'   t := CNT - t
	getct	result1
	sub	result1, _var_T
	mov	result3, result1
	mov	result1, _var_Lo
_Cordicmul_ret
	reta

' 
' PUB hwmul(a, b) : lo, hi, t | ahi, bhi
pasm_Hwmul
_Hwmul
'   t := CNT
	getct	result1
	mov	_var_T, result1
'   ahi := a>>16
	mov	_var_03, arg1
	shr	_var_03, #16
'   bhi := b>>16
	mov	_var_04, arg2
	shr	_var_04, #16
	mov	_var_Lo, arg1
	mov	result2, _var_03
	mul	_var_Lo, arg2
	mul	result2, _var_04
	mul	_var_03, arg2
	mul	_var_04, arg1
	mov	arg1, _var_03
	shl	arg1, #16
	shr	_var_03, #16
	mov	arg2, _var_04
	shl	arg2, #16
	shr	_var_04, #16
	add	_var_Lo, arg1 wc
	addx	result2, _var_03
	add	_var_Lo, arg2 wc
	addx	result2, _var_04
'   asm
'     mov lo, a
'     mov hi, ahi
'     mul lo, b
'     mul hi, bhi
'     mul ahi, b
'     mul bhi, a
'     mov a, ahi
'     shl a, #16
'     shr ahi, #16
'     mov b, bhi
'     shl b, #16
'     shr bhi, #16
'     add lo, a wc
'     addx hi, ahi
'     add lo, b wc
'     addx hi, bhi
'   endasm
'   t := CNT - t
	getct	result1
	sub	result1, _var_T
	mov	result3, result1
	mov	result1, _var_Lo
_Hwmul_ret
	reta

' 
' {
' PRI add64(alo, ahi, blo, bhi): rlo, rhi
'   rlo := alo
'   rhi := ahi
'   asm
'     add rlo, blo wc
'     addx rhi, bhi
'   endasm
' }
'  
' PUB swmul(a, b): lo, hi, t | bhi
pasm_Swmul
_Swmul
'   t := CNT
	getct	result1
	mov	_var_T, result1
'   lo := 0
	mov	_var_Lo, #0
'   hi := 0
	mov	_var_Hi, #0
'   bhi := 0
	mov	_var_03, #0
'   repeat while (a <> 0)
	cmps	arg1, #0 wz
 if_e	jmp	#L__0011
L__0013
'     if (a&1)
	test	arg1, #1 wz
 if_ne	add	_var_Lo, arg2 wc
 if_ne	addx	_var_Hi, _var_03
	add	arg2, arg2 wc
	addx	_var_03, _var_03
'       ''(lo,hi) := add64(lo, hi, b, bhi)
'       asm
'         add lo, b wc
'         addx hi, bhi
'       endasm
'     '
'     '(b, bhi) := add64(b, bhi, b, bhi)
'     asm
'       add b, b wc
'       addx bhi, bhi
'     endasm
'     a >>= 1
	shr	arg1, #1 wz
 if_ne	jmp	#L__0013
L__0011
'  
'   t := CNT - t
	getct	result1
	sub	result1, _var_T
	mov	result3, result1
	mov	result1, _var_Lo
	mov	result2, _var_Hi
_Swmul_ret
	reta

multiply_
	mov	itmp2_, muldiva_
	xor	itmp2_, muldivb_
	abs	muldiva_, muldiva_
	abs	muldivb_, muldivb_
	qmul	muldiva_, muldivb_
	getqx	muldiva_
	getqy	muldivb_
	shr	itmp2_, #31 wz
 if_nz	neg	muldivb_, muldivb_
 if_nz	neg	muldiva_, muldiva_ wz
 if_nz	sub	muldivb_, #1
	reta

itmp1_
	long	0
itmp2_
	long	0
mboxcmd
	long	0
mboxptr
	long	0
objptr
	long	0
result1
	long	0
result2
	long	0
result3
	long	0
COG_BSS_START
	fit	496
	orgh	$800
	long	80000000
	long	100
	org	COG_BSS_START
_var_03
	res	1
_var_04
	res	1
_var_Hi
	res	1
_var_Lo
	res	1
_var_T
	res	1
arg1
	res	1
arg2
	res	1
arg3
	res	1
arg4
	res	1
muldiva_
	res	1
muldivb_
	res	1
	fit	496
__fixup_ptr
	long	0
